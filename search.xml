<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[观后感]]></title>
    <url>%2F2020%2F06%2F07%2F%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[前言一些笔记。 应物兄观后感《应物兄》以应物兄作为主线，讲述太和研究院的立项到建立过程中的一些故事。 开篇，从校长葛道宏提议建立儒学研究院，任命应物兄为副院长开始讲述，葛道宏推荐费鸣作为应物兄助理，引出与乔木、乔木学生费鸣、出版商季宗慈等人物关系，并通过应物兄作品《孔子是条丧家狗》出版前后的一些故事，将之前人物关系串联起来，并讲述了与费明恩怨产生与化解。之后，通过讲述乔木先生的狗木瓜（moon）看病咬伤铁梳子狗的内容引出铁梳子、卡尔文等人。并逐渐通过两弹元勋双林院士引出程济世先生，程济世作为儒学大师，意欲归国，因此才有了儒学研究院的产生。 为实现程济世先生的回国，在济州担任儒学研究院院长，省内各官员栾庭玉、邓林等，各企业家铁梳子、雷山巴等各为己欲，通过满足程济世各种需求，来实现各自的权、钱愿望。针对程济世先生提出的听济哥需求，任命华学明进行济哥的“复生”，华学明作为生命科学院领头人，为了程济世先生的童年梦想，担负着羽化已经灭绝的济哥的重任，他全身心投入实验中，直至精神状况出现问题。针对程济世提出的程家大观园作为太和研究院需求，开始各种查找与论证大观园原址。并讲述了接待程济世先生弟子企业家黄兴（子贡）的超规格礼遇，来引进外企的投资。 书末随着，各老一辈的学者、专家的逐渐离世，各位雷山巴、吴镇、董松龄等与程济世有各种关系或出资到太和中的人物，各种安插人员至太和研究院。最终，通过揭露大观园原址与实际位置不符，阐明本书对各种角色的讽刺。 ##]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Book Review</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2020%2F06%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言一些笔记。 设计模式简单工厂 1234567891011121314151617181920212223242526272829303132333435public abstract class Operation&#123; private double numberA; private double numberB; public double getResult();&#125;public class OperationAdd extends Operation&#123; @override public double getResult()&#123; return numberA + numberB; &#125;&#125;public class OperationSub extends Operation&#123; @override public double getResult()&#123; return numberA - numberB; &#125;&#125;public class OperationFactory&#123; public Operation CreateOperate(String operate)&#123; Operation oper; switch(operate)&#123; case "+": oper = new OperationAdd(); break; case "-": oper = new OperationSub(); break; &#125; return oper; &#125;&#125; 工厂方法 123456789101112131415public interface IFactory&#123; Operation createOperation();&#125;public AddFactory extends IFactory&#123; Operation createOperation()&#123; return new OperationAdd(); &#125;&#125;public SubFactory extends IFactory&#123; Operation createOperation()&#123; return new OperationSub(); &#125;&#125; 原型模式 原型模式采用深复制、潜复制技术，实现针对某一个对象的复制与修改。 建造者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Client&#123; public static void main(String[] args)&#123; PersonThinBuilder ptb = new PersonThinBuilder(55); PersonDirector pdThin = new PersonDirector(ptb); pdThin.createPerson(); PersonFatBuilder pfb = new PersonFatBuilder(55); PersonDirector pdFat = new PersonDirector(pfb); pdFat.createPerson(); &#125;&#125;public class PersonDirector&#123; private PersonBuilder pb; public PersonDirector(PersonBuilder pb)&#123; this.pb = pb; &#125; public void createPerson&#123; pb.buildHead(); pb.buildBody(); pb.buildArm(); pb.buildLeg(); &#125;&#125;public abstract class PersonBuilder&#123; int weight; public PersonBuilder(int weight)&#123; this.weight = weight; &#125; public void buildHead(); public void buildBody(); public void buildArm(); public void buildLeg();&#125;public class PersonThinBuilder extends PersonBuilder&#123; @override public void buildHead()&#123; System.out.print("thin man head“); &#125; @override public void buildBody()&#123; System.out.print("thin man body weight is“ + weight); &#125; @override public void buildArm()&#123; System.out.print("thin man arm“); &#125; @override public void buildLeg()&#123; System.out.print("thin man leg“); &#125;&#125; 策略模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class CashContext&#123; private CashSuper cs; public CashContext(String type)&#123; CashSuper csuper; switch(type)&#123; case "normal": csuper = new CashContext(new CashNormal()); break; case "300 - 100": csuper = new CashContext(new CashReturn(300, 100)); break; case "80%": csuper = new CashContext(new CashRebate(0.8)); break; &#125; this.cs = csuper; &#125; public double getResult(double money)&#123; return cs.acceptCash(money); &#125; public static void main(String[] args)&#123; CashContext cc = new CashContext("normal"); double totalPrice = cc.getResult(args[2]); &#125;&#125;public interface CashSuper&#123; public double acceptCash(double mony);&#125;public class CashNormal implements CashSuper&#123; @override public double acceptCash(double mony)&#123; return money; &#125;&#125;public class CashRebate implements CashSuper&#123; private double moneyRebate; public CashRebate(double moneyRebate)&#123; this.moneyRebate = moneyRebate; &#125; @override public double acceptCash(double mony)&#123; return money * moneyRebate; &#125;&#125; 装饰模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person&#123; private String name; public Person(string name)&#123; this.name = name; &#125; public void show()&#123; System.out.print(" finery " + name); &#125; public static void main(String[] args)&#123; Person xm = new Person("xiaoming"); TShirt xm1 = new TShirt(xm); BigTrouser xm2 = new BigTrouser(xm1); xm2.show(); &#125;&#125;class Finery extends Person&#123; protected Person component; public Finery(Person component)&#123; this.component = component; &#125; @override public void show()&#123; if(component != null)&#123; component.show(); &#125; &#125;&#125;class TShirt extends Finery&#123; @override public void show()&#123; System.out.print("T-Shirt " + name); super.show(); &#125;&#125;class BigTrouser extends Finery&#123; @override public void show()&#123; System.out.print("BigTrouser " + name); super.show(); &#125;&#125; 代理模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Client&#123; public static void main(String[] args)&#123; SchoolGirl xiaohong = new SchoolGirl(); xiaohong.name = "xiaophong"; Proxy proxy = new Proxy(xiaohong); proxy.giveFlowers(); proxy.giveChocolate(); &#125;&#125;public interface GiveGift&#123; void giveFlowers(); void giveChocolate()&#125;public SchoolGirl&#123; String name;&#125;public class Pursuit impletments GiveGift&#123; SchoolGirl mm; public Pursuit(SchoolGirl mm)&#123; this.mm = mm; &#125; @override public void giveFlowers()&#123; System.out.print(mm.name + " give flowers"); &#125; @override public void giveChocolate()&#123; System.out.print(mm.name + " give chocolate"); &#125;&#125;public class Proxy extends GiveGift&#123; Pursuit gg; public Proxy(SchoolGirl mm)&#123; gg = new Pursuit(mm); &#125; @override public void giveFlowers()&#123; gg.giveFlowers(); &#125; @override public void giveChocolate()&#123; gg.giveChocolate(); &#125;&#125; 模板方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Client&#123; public static void main(String[] args)&#123; TestPaper tp1 = TestPaperA(); tp1.getPaper(); TestPaper tp2 = TestPaperB(); tp2.getPaper(); &#125;&#125;public class TestPaper&#123; public void question1()&#123; System.out.print("1 + 2 = [] : a.3 b.4 c.1 d.2"); &#125; public void question1()&#123; System.out.print("1 * 2 = [] : a.3 b.4 c.1 d.2"); &#125; public void answer1()&#123; System.out.print("d"); &#125; public void answer1()&#123; System.out.print("d"); &#125; public void getPaper()&#123; question1(); answer1(); System.out.print("----------"); question2(); answer2(); &#125;&#125;public class TestPaperA&#123; @override public void answer1()&#123; System.out.print("c"); &#125; @override public void answer1()&#123; System.out.print("d"); &#125;&#125;public class TestPaperB&#123; @override public void answer1()&#123; System.out.print("d"); &#125; @override public void answer1()&#123; System.out.print("a"); &#125;&#125; 外观模式 12345678910111213141516171819202122232425262728293031323334353637383940public class Client&#123; public static void main(String[] args)&#123; Fund fund = new Fund(); fund.buyFund(); fund.sellFund(); &#125;&#125;public class Fund&#123; Stock1 stock1; Stock2 stock2; Stock3 stock4; public Fund&#123; stock1 = new Stock1(); stock2 = new Stock2(); stock3 = new Stock3(); &#125; public void buyFund()&#123; stock1.buy(); stock2.buy(); stock3.buy(); &#125; public void sellFund&#123; stock1.sell(); stock2.sell(); stock3.sell(); &#125;&#125;public class Stock1&#123; public buy()&#123; System.out.print("buy stock 1"); &#125; public sell()&#123; System.out.print("buy stock 1"); &#125;&#125; 观察者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Client&#123; public static void main(String[] args)&#123; Boss boss = new Boss(); boss.attach(new StockObserver(boss)); boss.attach(new TVObserver(boss)); boss.subjectState = "back"; boss.notofy(); &#125;&#125;public interface Subject&#123; String subjectState; void attach(Observer observer); void detach(Observer observer);&#125;public Boss implements Subject&#123; private List&lt;Observer&gt; observers = new ArrayList(); @override public void attach(Observer observer)&#123; observers.add(observer); &#125; @override public void detach(Observer observer)&#123; observers.remove(observer); &#125; public void notify()&#123; for(Observer o : observers)&#123; o.update(); &#125; &#125;&#125;public abstract class Observer&#123; Subject sub; public Observer(Subject sub)&#123; this.sub = sub; &#125; public void update();&#125;public class StockObserver extends Observer&#123; public StockObserver(Subject sub)&#123; super(sub); &#125; @override public void update()&#123; System.out.print("xx is " + sub.subjectState + " stop watching stock, go to work"); &#125;&#125;public class TVObserver extends Observer&#123; public TVObserver(Subject sub)&#123; super(sub); &#125; @override public void update()&#123; System.out.print("xx is " + sub.subjectState + "stop watching TV, go to work"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>design mode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch]]></title>
    <url>%2F2020%2F06%2F07%2FArch%2F</url>
    <content type="text"><![CDATA[前言一些笔记。 网络配置 Deprecated command Replacement commands arp ip neighbor ifconfig ip address, ip link netstat ss route ip route As a result the system resolves to both entries: 1234$ getent hosts127.0.0.1 localhost127.0.0.1 localhost127.0.1.1 myhostname.localdomain myhostname To manually set an alias, for some NIC, use iproute2 to execute 1# ip addr add 192.168.2.101/24 dev eth0 label eth0:1 To remove a given alias execute 1# ip addr del 192.168.2.101/24 dev eth0:1 包管理To install a single package or list of packages, including dependencies, issue the following command: 1# pacman -S package_name1 package_name2 ... To remove a single package, leaving all of its dependencies installed: 1# pacman -R package_name GRUBUse the grub-mkconfig tool to generate /boot/grub/grub.cfg: 1# grub-mkconfig -o /boot/grub/grub.cfg Install the grub package. (BISO) Then do: 1# grub-install --target=i386-pc /dev/sdX dhcpcdTo start the daemon for all network interfaces, start/enable dhcpcd.service. 1dhcpcd ens33 #使能接口dhcp deepin安装 1pacman -S deepin 定时任务编辑/etc/crontab，23点通过root权限运行/sbin/shutdown -h now 100 23 * * * root /sbin/shutdown -h now 登录不上显示： 1System is booting up. Unprivileged users are not permitted to log in yet. Please come back later. For technical details, see pam_nologin(8). ，执行 1ls -l /run/nologin]]></content>
      <categories>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ONOS-2.2]]></title>
    <url>%2F2020%2F06%2F07%2F%E6%9C%80%E6%96%B0ONOS%2F</url>
    <content type="text"><![CDATA[前言一些笔记。 编译编译命令： 12$ cd $ONOS_ROOT$ bazel build onos 创建API文档： 12bazel build //docs:externalbazel build //docs:internal 创建新应用： 1onos-create-app app org.foo foo-app 1.0-SNAPSHOT org.foo.app ONOS版本可在onos/tools/build/bazel/variables.bzl中查看]]></content>
      <categories>
        <category>ONOS-2.2</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>ONOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PYTHON的一些笔记]]></title>
    <url>%2F2020%2F06%2F07%2Fpython%2F</url>
    <content type="text"><![CDATA[前言一些笔记。 PYTHON的一些笔记打印间隔符输出： 12&gt;&gt;&gt; print(' cats', 'dogs', 'mice', sep=',')cats, dogs, mice 列表删除： 1del spam[ 2] 判断存在： 12345&gt;&gt;&gt; spam = ['hello', 'hi', 'howdy', 'heyas'] &gt;&gt;&gt; 'cat' in spam False &gt;&gt;&gt; 'howdy' not in spamFalse 列表中查找值： 123&gt;&gt;&gt; spam = ['hello', 'hi', 'howdy', 'heyas'] &gt;&gt;&gt; spam. index(' hello')0 列表可用append()，insert(1, ‘chicken’)，remove(‘bat’)，sort()方法；采用copy.copy()浅拷贝，copy.deepcopy()深拷贝。 字典字典可用keys()，values()，items()表示键、值、键-值的元组；setdefault(’color’, ‘black’)设置默认值，键不存在的默认值 字符串in和not in可判断字符串中的包含；字符串具有如下方法： 函数 说明 upper() 变为大写 lower() 变为小写 isupper() 全为大写 islower() 全为小写 isalpha() 全为字母 isalnum() 为数字或字母 isdecimal() 为数字 isspace() 只包括空格、tab、换行 istitle() 大写字母开头后面为小写字母’This Is Title Case 123’ startwith() 以…开头 endswith() 以..结束 join() '.join([' cats', 'rats', 'bats']) ```输出```'cats, rats, bats'``` |123456789101112131415161718192021| split() | || rjust() ljust() center() | ```&apos;Hello&apos;. rjust(20， &apos;*&apos;)```输出```&apos;****************Hello&apos;``` || strip() rstrip() lstrip() | 删除空白符 |## 正则表达式python正则表达式使用如下：```python&gt;&gt;&gt; phoneNumRegex = re. compile( r&apos;(\ d\ d\ d)-(\ d\ d\ d-\ d\ d\ d\ d)&apos;) &gt;&gt;&gt; mo = phoneNumRegex. search(&apos; My number is 415- 555- 4242.&apos;) &gt;&gt;&gt; mo. group(1) &apos;415&apos; &gt;&gt;&gt; mo. group(2) &apos;555- 4242&apos; &gt;&gt;&gt; mo. group(0) &apos;415- 555- 4242&apos; &gt;&gt;&gt; mo. group() &apos;415- 555- 4242&apos;phoneNumRegex. findall(&apos; Cell: 415- 555- 9999 Work: 212- 555- 0000&apos;) [(&apos;415&apos;, &apos;555&apos;, &apos;1122&apos;), (&apos;212&apos;, &apos;555&apos;, &apos;0000&apos;)] 正则表达式符号： 符号 说明 \d 0-9数字 \D 除0-9数字以外字符 \w 任何字母、数字、下划线 \W 除字母、数字、下划线以外字符 \s 空格、tab、换行 \S 除空格、tab、换行以外字符 ？ 可选，ow可以存在：(ow)? * 零次或多次，ow可以由零次或多次：(ow)* + 一次或多次，ow可以由一次或多次：(ow)+ {3} 特定次数，(ow){3}三次，(ow)(3,)至少三次，(ow)(3,5)三到五次 [aeiou] 指定为某一个 ^ 以…开头 $ 以…结束 . 除了换行之外所有字符 指定规则re. IGNORECASE 或 re. I不区分大小写：re.compile(r’abc’, re.I)。 sub字符串替换： 123&gt;&gt;&gt; agentNamesRegex = re.compile( r'Agent (\w)\w*')&gt;&gt;&gt; agentNamesRegex.sub( r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.') A**** told C**** that E**** knew B**** was a double agent. 读写文件当前路径： 123456&gt;&gt;&gt; import os &gt;&gt;&gt; os.getcwd()'C:\\Python34'&gt;&gt;&gt; os.chdir('C:\\Windows\\System32') &gt;&gt;&gt; os.getcwd() 'C:\\ Windows\\ System32' 文件读写： 12345678910111213&gt;&gt;&gt; baconFile = open('bacon.txt', 'w')&gt;&gt;&gt; baconFile.write('Hello world!\n')13 &gt;&gt;&gt; baconFile.close()&gt;&gt;&gt; baconFile = open('bacon.txt', 'a')&gt;&gt;&gt; baconFile.write('Bacon is not a vegetable.') 25 &gt;&gt;&gt; baconFile. close() &gt;&gt;&gt; baconFile = open('bacon. txt')&gt;&gt;&gt; content = baconFile.read() &gt;&gt;&gt; baconFile.close() &gt;&gt;&gt; print(content)Hello world! Bacon is not a vegetable. 可以利用 shelve 模块，将Python程序中的变量保存到二进制的shelf文件中。 使用shutil（ 或称为 shell 工具） 模块中包含 一些函数，在Python程序中复制、移动、改名和删除文件。 日志与断言断言，判断是否相等，不等则输出异常： 1assert 'red' in stoplight. values(), 'Neither light is red! ' 日志用法： 12345&gt;&gt;&gt; import logging&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')&gt;&gt;&gt; logging. debug(' Some debugging details.')2015-05-18 19:04:26,901 - DEBUG - Some debugging details.&gt;&gt;&gt; logging.basicConfig( filename='myProgramLog.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') 其他结束程序： 1sys. exit() None值： 1234&gt;&gt;&gt; spam = print(' Hello!') Hello! &gt;&gt;&gt; None == spam True global指向全局变量，如下输出spam: 1234567def spam(): global eggs eggs = 'spam'eggs = 'global'spam()print( eggs) pyperclip 模块有 copy() 和 paste() 函数， 可以向计算机的剪贴板发送文本，或从它接收文本。]]></content>
      <categories>
        <category>PYTHON的一些笔记</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot笔记]]></title>
    <url>%2F2019%2F01%2F23%2FSpringboot%2F</url>
    <content type="text"><![CDATA[SpringbootJAP的使用方式1 配置文件在.properies中填写JPA连接MySql的配置： 12345678spring.datasource.url=jdbc:mysql://192.168.0.120:3306/blogspring.datasource.username=jingspring.datasource.password=***spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=create 前面为连接数据mysql的配置，后面为JPA的配置。与此同时需要在MAVEN配置文件中添加依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2 实体Bean123456789101112131415161718192021222324252627@Entitypublic class Article &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) @ApiModelProperty(hidden = true) private Long id; private String title; private String description; private Date createTime; private String content; private int readCount; @ManyToOne private User user; @ManyToOne private Category category; @ManyToMany private Set&lt;Label&gt; labels; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; //...&#125; 实体Bean需要用@Entity修饰，主键需要用@Id修饰，@GeneratedValue为可选注解，描述了主键的生成方式，这样主键可以自动依靠JPA生成。@ApiModelProperty(hidden = true)注解表明该属性不对接口暴漏出去，适合主键和一些自动生成的属性。@ManyToOne、@ManyToMany等描述了表的属性之间关系，JPA会自动依据注解的关系生成外键。 3 Repository接口Repository接口继承了JpaRepository，通过JPA实现了对相应的实体Bean的操作。 123@Repositorypublic interface ArticleRepository extends JpaRepository&lt;Article, Long&gt; &#123;&#125; 该接口需要被@Repository进行描述，这样JPA才会读取这个接口。在JpaRepository&lt;Article, Long&gt;中需要描述操作的实体Bean的类型与该类的主键类型。 4 Controller类Controller类实现了路由与操作封装。 1234567891011121314151617181920@RestController@RequestMapping("/articles")public class ArticleController &#123; @Autowired private ArticleRepository articleRepository; @ApiOperation(value = "获取文章列表") @RequestMapping(value = "",method = RequestMethod.GET) public List&lt;Article&gt; getArticles() &#123; List&lt;Article&gt; articles = new ArrayList&lt;&gt;(articleRepository.findAll()); return articles; &#125; @ApiOperation(value = "创建文章" , notes = "根据article对象创建文章") @ApiImplicitParam(name = "article",value = "文章详情实体类",required = true,dataType = "Article") @RequestMapping(value = "",method = RequestMethod.POST) public String postArticle(@RequestBody Article article) &#123; articleRepository.save(article); return "添加成功~~~"; &#125;&#125; Controller需要通过@RequestMapping(“/articles”)指定路由的URL，若为REST的接口形式则需要在类上添加@RestController描述。 在类中需要添加相应的Repository类的实例对象，并用@Autowired进行描述方便JPA进行查找与实例化，通过该对象可以实现对实体Bean的增删操作，并直接映射到数据库中。 操作函数需要@RequestMapping(value = “”,method = RequestMethod.GET)进行描述，表面操作的方法，其中value为请求的下一级URL，若存在多个GET或多个POST方法时需要该值进行区分。 函数中通过操作Repository接口的对象进行数据的增删改查功能。 日志springboot使用slf4j日志api，使用如下： 123456Logger logger = LoggerFactory.getLoger(getClass());logger.trace("日志信息")；logger.info("日志信息")；logger.debug("日志信息")；logger.warn("日志信息")；logger.error("日志信息")； 日志配置信息如下： 12logging.level.com.test=info logging.path=/spring/log 页面资源首页默认为resources/static或public、resources下的index.html文件，并指向/路径。首页标签图标favicon.ico]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty源代码解析]]></title>
    <url>%2F2019%2F01%2F15%2FNetty%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Netty源代码解析bind操作Netty-4.1.8的NIO代码进入从bind事件开始： 1serverBootstrap.bind(8888) 该事件会追踪到AbstractBootstrap抽象类中，通过validate进行group和channelFactory的非空校验，之后执行doBind。 1234567public ChannelFuture bind(SocketAddress localAddress) &#123; validate(); if (localAddress == null) &#123; throw new NullPointerException("localAddress"); &#125; return doBind(localAddress);&#125; doBind函数也位于AbstractBootstrap中，首先通过initAndRegister进行通道的初始化和注册，之后执行doBind0。 12345678910111213141516private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // ...省略 &#125;&#125; 1 initAndRegister在initAndRegister中分为通过工厂创建channel，init初始化通道，和通道注册三个过程。 12345678910111213141516171819final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; channel = channelFactory.newChannel(); init(channel); &#125; catch (Throwable t) &#123; if (channel != null) &#123; // channel can be null if newChannel crashed (eg SocketException("too many open files")) channel.unsafe().closeForcibly(); &#125; // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; ChannelFuture regFuture = config().group().register(channel); //...省略 return regFuture;&#125; 1.1 创建Channel工厂创建通过ReflectiveChannelFactory中的newChannel实现，实际为通过反射调用通过channel()方法配置的工厂方法。 12345678@Overridepublic T newChannel() &#123; try &#123; return clazz.newInstance(); &#125; catch (Throwable t) &#123; throw new ChannelException("Unable to create Channel from class " + clazz, t); &#125;&#125; 1.2 init初始化通道服务端的初始化通道在ServerBootstrap类中，分为Boss线程通道的Option和attrs设置、Worker线程通道的Option和attrs设置、向通道中添加默认的pipline。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void init(Channel channel) throws Exception &#123; final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0(); synchronized (options) &#123; setChannelOptions(channel, options, logger); &#125; final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0(); synchronized (attrs) &#123; for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123; @SuppressWarnings("unchecked") AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey(); channel.attr(key).set(e.getValue()); &#125; &#125; ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions; final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs; synchronized (childOptions) &#123; currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size())); &#125; synchronized (childAttrs) &#123; currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size())); &#125; p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; @Override public void initChannel(Channel ch) throws Exception &#123; final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) &#123; pipeline.addLast(handler); &#125; // We add this handler via the EventLoop as the user may have used a ChannelInitializer as handler. // In this case the initChannel(...) method will only be called after this method returns. Because // of this we need to ensure we add our handler in a delayed fashion so all the users handler are // placed in front of the ServerBootstrapAcceptor. ch.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; pipeline.addLast(new ServerBootstrapAcceptor( currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); &#125; &#125;); &#125; &#125;);&#125; 1.3 通道注册通道注册通过group().register()进行，group为线程池，因此调用进MultithreadEventLoopGroup类中的register函数，其中next()为线程池中的一个线程，调用进SingleThreadEventLoop类： 123public ChannelFuture register(Channel channel) &#123; return register(new DefaultChannelPromise(channel, this));&#125; 将channel和SingleThreadEventLoop类自己封装到DefaultChannelPromise传入register： 12345public ChannelFuture register(final ChannelPromise promise) &#123; ObjectUtil.checkNotNull(promise, "promise"); promise.channel().unsafe().register(this, promise); return promise;&#125; 之后将SingleThreadEventLoop类自己和DefaultChannelPromise传入AbstractChannel类中的register函数。 12345678910111213141516171819202122232425public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123; //...省略 AbstractChannel.this.eventLoop = eventLoop; if (eventLoop.inEventLoop()) &#123; register0(promise); &#125; else &#123; try &#123; eventLoop.execute(new Runnable() &#123; @Override public void run() &#123; register0(promise); &#125; &#125;); &#125; catch (Throwable t) &#123; logger.warn( "Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;", AbstractChannel.this, t); closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); &#125; &#125;&#125; 该函数的if语句判断为：在线程内部运行则执行if否则执行else，此时在线程外部，执行else，即eventLoop.execute(…)，该操作将register0封装为Runnable传入execute内。 1234567891011121314151617181920public void execute(Runnable task) &#123; if (task == null) &#123; throw new NullPointerException("task"); &#125; boolean inEventLoop = inEventLoop(); if (inEventLoop) &#123; addTask(task); &#125; else &#123; startThread(); addTask(task); if (isShutdown() &amp;&amp; removeTask(task)) &#123; reject(); &#125; &#125; if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123; wakeup(inEventLoop); &#125;&#125; excute函数分为线程内操作和线程外操作，此时执行线程外操作，即执行startThread与addTask。 1.3.1 startThreadstrartThread最终调入进doStartThread， 1234567891011121314151617181920212223private void doStartThread() &#123; assert thread == null; executor.execute(new Runnable() &#123; @Override public void run() &#123; thread = Thread.currentThread(); if (interrupted) &#123; thread.interrupt(); &#125; boolean success = false; updateLastExecutionTime(); try &#123; SingleThreadEventExecutor.this.run(); success = true; &#125; catch (Throwable t) &#123; logger.warn("Unexpected exception from an event executor: ", t); &#125; finally &#123; //...省略 &#125; &#125; &#125;);&#125; 此处executor为ThreadPerTaskExecutor，创建线程并执行Runnable，此时进入了线程的运行部分。 线程执行SingleThreadEventExecutor.this.run，SingleThreadEventExecutor实现为NioEventLoop，此处为死循环，保证子线程一致运行。子线程判断是否发生了select事件并执行processSelectedKeys和runAllTasks。此时未注册select key也未加入task。 1234567891011121314151617181920212223242526272829303132333435363738394041protected void run() &#123; for (;;) &#123; try &#123; switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); if (wakenUp.get()) &#123; selector.wakeup(); &#125; default: // fallthrough &#125; cancelledKeys = 0; needsToSelectAgain = false; final int ioRatio = this.ioRatio; if (ioRatio == 100) &#123; try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. runAllTasks(); &#125; &#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; //... 省略 &#125;&#125; 1.3.2 addTask执行addTask加入任务，此时task为传入的Runnable，即执行register0函数。 1234567891011121314151617181920212223242526272829303132333435363738private void register0(ChannelPromise promise) &#123; try &#123; // check if the channel is still open as it could be closed in the mean time when the register // call was outside of the eventLoop if (!promise.setUncancellable() || !ensureOpen(promise)) &#123; return; &#125; boolean firstRegistration = neverRegistered; doRegister(); neverRegistered = false; registered = true; // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the // user may already fire events through the pipeline in the ChannelFutureListener. pipeline.invokeHandlerAddedIfNeeded(); safeSetSuccess(promise); pipeline.fireChannelRegistered(); // Only fire a channelActive if the channel has never been registered. This prevents firing // multiple channel actives if the channel is deregistered and re-registered. if (isActive()) &#123; if (firstRegistration) &#123; pipeline.fireChannelActive(); &#125; else if (config().isAutoRead()) &#123; // This channel was registered before and autoRead() is set. This means we need to begin read // again so that we process inbound data. // // See https://github.com/netty/netty/issues/4805 beginRead(); &#125; &#125; &#125; catch (Throwable t) &#123; // Close the channel directly to avoid FD leak. closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); &#125;&#125; register0函数包括doRegister执行注册、invokeHandlerAddedIfNeeded调用handler、fireChannelRegistered通知通道注册事件、若首次注册则执行fireChannelActive否则beginRead。 doRegister doRegister在AbstractNioChannel中将通道通过DK中的register操作注册到select操作中。 12345678910protected void doRegister() throws Exception &#123; boolean selected = false; for (;;) &#123; try &#123; selectionKey = javaChannel().register(eventLoop().selector, 0, this); return; &#125; catch (CancelledKeyException e) &#123; //...省略 &#125;&#125; invokeHandlerAddedIfNeeded 该函数最终调用到callHandlerAddedForAllHandlers中，执行this.pendingHandlerCallbackHead，经过追踪可知，为pipline.addLast添加的channlHandler。 12345678910111213141516171819private void callHandlerAddedForAllHandlers() &#123; final PendingHandlerCallback pendingHandlerCallbackHead; synchronized (this) &#123; assert !registered; // This Channel itself was registered. registered = true; pendingHandlerCallbackHead = this.pendingHandlerCallbackHead; // Null out so it can be GC'ed. this.pendingHandlerCallbackHead = null; &#125; PendingHandlerCallback task = pendingHandlerCallbackHead; while (task != null) &#123; task.execute(); task = task.next; &#125;&#125; 通过调用最终指向channelInitilizer，即在“2 初始化init通道”中p.addLast添加的匿名ChannelInitializer。 fireChannelRegistered 最终进入AbstractChannelHandlerContext类中，执行invokeChannelRegistered注册handler 12345678910111213141516171819202122232425static void invokeChannelRegistered(final AbstractChannelHandlerContext next) &#123; EventExecutor executor = next.executor(); if (executor.inEventLoop()) &#123; next.invokeChannelRegistered(); &#125; else &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; next.invokeChannelRegistered(); &#125; &#125;); &#125;&#125;private void invokeChannelRegistered() &#123; if (invokeHandler()) &#123; try &#123; ((ChannelInboundHandler) handler()).channelRegistered(this); &#125; catch (Throwable t) &#123; notifyHandlerException(t); &#125; &#125; else &#123; fireChannelRegistered(); &#125;&#125; 由于此时由于handler未注册。最终执行DefaultChannelPipline中的空函数channelRegistered。 fireChannelActive 由于此时未有客户端连入，isActive不能进入，因此不会执行到fireChannelActive。 2 doBind0doBind0通过将channel.bind()操作封装为Runnable通过execute装入task队列，最终在runAllTasks中执行。 1234567891011121314151617private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) &#123; // This method is invoked before channelRegistered() is triggered. Give user handlers a chance to set up // the pipeline in its channelRegistered() implementation. channel.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; if (regFuture.isSuccess()) &#123; channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); &#125; else &#123; promise.setFailure(regFuture.cause()); &#125; &#125; &#125;);&#125; channel.bind最终会进入AbstractChannelHandlerContext的bind函数，在该函数中由于在线程中执行进入next.invokeBind。 1234567891011121314151617181920212223public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) &#123; if (localAddress == null) &#123; throw new NullPointerException("localAddress"); &#125; if (!validatePromise(promise, false)) &#123; // cancelled return promise; &#125; final AbstractChannelHandlerContext next = findContextOutbound(); EventExecutor executor = next.executor(); if (executor.inEventLoop()) &#123; next.invokeBind(localAddress, promise); &#125; else &#123; safeExecute(executor, new Runnable() &#123; @Override public void run() &#123; next.invokeBind(localAddress, promise); &#125; &#125;, promise, null); &#125; return promise;&#125; 最终会进入NioServerSocketChannel中执行doBind，进行JDK的bind操作。 1234567protected void doBind(SocketAddress localAddress) throws Exception &#123; if (PlatformDependent.javaVersion() &gt;= 7) &#123; javaChannel().bind(localAddress, config.getBacklog()); &#125; else &#123; javaChannel().socket().bind(localAddress, config.getBacklog()); &#125;&#125; read操作1 读事件注册若有客户端到来，会触发执行register0，注册通过doRegister客户端，在invokeHandlerAddedIfNeeded中添加handler，此时最终会指向用户创建服务端的代码的serverBootstrap.childHandler中创建的ChannelInitializer，实现用户的Handler的注册。 1234567serverBootstrap.childHandler(new ChannelInitializer() &#123; protected void initChannel(Channel channel) throws Exception &#123; ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHandler()); &#125;&#125;); 注册完成会执行fireChannelRegister，此时invokeHandlerAddedIfNeeded由于非第一次注册，直接跳过。 1234public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123; invokeHandlerAddedIfNeeded(); ctx.fireChannelRegistered();&#125; 之后执行fireChannelRegistered和fireChannelActive，此时fireChannelActive进入执行，并最终进入DefaultChannelPipline的channelActive函数。 12345public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.fireChannelActive(); readIfIsAutoRead();&#125; 该函数分为fireChannelActive与readIfIsAutoRead。 1.1 fireChannelActive其中fireChannelActive会最终进入invokeChannelActive，由于在线程中，进入AbstractChannelHandlerContext的invokeChannelActive。 12345678910111213static void invokeChannelActive(final AbstractChannelHandlerContext next) &#123; EventExecutor executor = next.executor(); if (executor.inEventLoop()) &#123; next.invokeChannelActive(); &#125; else &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; next.invokeChannelActive(); &#125; &#125;); &#125;&#125; 同样还未有handler注册最终执行DefaultChannelPipline中的空函数channelRegistered。 1.2 readIfIsAutoReadreadIfIsAutlRead进行Read事件的注册。 12345private void readIfIsAutoRead() &#123; if (channel.config().isAutoRead()) &#123; channel.read(); &#125;&#125; 最终会调入进AbstractNioChannel中的doBeginRead函数进行select key的读操作注册。 1234567891011121314protected void doBeginRead() throws Exception &#123; // Channel.read() or ChannelHandlerContext.read() was called final SelectionKey selectionKey = this.selectionKey; if (!selectionKey.isValid()) &#123; return; &#125; readPending = true; final int interestOps = selectionKey.interestOps(); if ((interestOps &amp; readInterestOp) == 0) &#123; selectionKey.interestOps(interestOps | readInterestOp); &#125;&#125; 2 读数据]]></content>
      <categories>
        <category>源码刨析</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO与Netty介绍]]></title>
    <url>%2F2019%2F01%2F13%2FNIO%E4%B8%8ENetty%2F</url>
    <content type="text"><![CDATA[NIO与Netty介绍NIO发展史在网络TCP的IO连接中服务端通过bind监听端口，accept接收连接，之后进行read/write操作。在bind与accept过程中是否一直等待称为阻塞/非阻塞，在read/write过程中是否需要等待数据从内核拷贝到用户态的过程称为同步/异步。 1 同步阻塞IO同步阻塞IO为服务端主线程bind端口后，等待客户端accept并进行read/write的过程。只能支持一个客户端的读写操作。 2 同步非阻塞IO同步非阻塞IO为服务端主线程bind端口后，启用子线程来等待客户端accept并进行read/write的过程。能够支持多个客户端的读写操作，但客户端与线程数量为1:1，占用资源过大。 3 单线程IO复用模型1第一类IO复用模型采用系统调用select/poll，通过使用select/poll来注册监听accept/read/write事件，实现对多个客户端的连接建立和读写操作。该方法客户端与线程的数量为N:1，节省资源，但客户端数量过大时影响性能。 4 多线程IO复用模型1可以通过采用多线程与IO复用模型相结合的方式，解决性能问题，该方式被称为NIO（Noblock IO/New IO）。该方式实现较为复杂，例如Netty为JAVA的NIO实现。 5 IO复用模型2在使用select/poll方式时，需要遍历所有注册的连接，即便有些连接没有事件到来，浪费了许多查询操作，于此提出epoll系统调用来改进该方式，epoll会通知到哪些连接有事件到来，防止了多余的检查操作。 6 异步IO异步IO使用aio_read等系统调用，实现读写操作的0等待，系统会将数据拷贝到用户空间后再通知有数据到来。 NettyNetty为JAVA的高并发底层实现，包括对上述的select方式NIO、epoll、AIO的实现。Netty的对多线程与并发操作进行了封装，在改变很少的情况下，便可实现多种方式的切换。如下为一个Netty服务端采用NIO的简单实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import io.netty.bootstrap.*;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;public class MyNettyServer &#123; public static void main(String[] args) &#123; NioEventLoopGroup bossGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap .group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childOption(ChannelOption.SO_KEEPALIVE, true); serverBootstrap.childHandler(new ChannelInitializer() &#123; protected void initChannel(Channel channel) throws Exception &#123; ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHandler()); &#125; &#125;); ChannelFuture channelFuture = serverBootstrap.bind(8888).sync(); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125;class MyHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(msg.toString()); &#125;&#125; 服务端的过程包括 创建NioEventLoopGroup线程池，包括Boss线程池、Worker线程池；Boss线程池实现accept操作并为Worker线程池分配连接，Worker线程池实现收发数据。一般Boss线程数为1，Worker线程默认为CPU核心2倍。 创建ServerBootstrap对象并绑定Boss线程池和Work线程池 指定socket通道建立的工厂方法如NioServerSocketChannel或者epoll、aio等。 配置socket的一些属性，如收发缓存大小、TCP的一些属性等。 设置handler，即对数据采取的处理与回应；可通过ChannelInitializer的initChannel在初始化通道的时候进行pipeline.addLast方式的添加，添加包括解码、操作、编码等。 执行bind方法绑定端口。 通过closeFuture最终连接断开后关闭连接。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPLS机制]]></title>
    <url>%2F2019%2F01%2F10%2FMPLS%2F</url>
    <content type="text"><![CDATA[MPLSMPLS是一种转发等价类技术。入边界节点push标签，中间节点switch标签，出节点pop标签，标签为本地有效。 转发等价类FEC，按相同方式，经相同路径，每跳转发行为均一致的IP包。 LDP分发标签，在路由器内形成LIB表，与转发表FIB形成LFIB表，其中FIB表根据路由表RIB多次递归查询生成。LIB与RIB属于控制层面，FIB与LFIB属于转发层面。 PHP倒数第二条弹出，最后一条分配隐含空标签，能够防止最后一跳二次查表（FIB表、LFIB表）。 AS内IBGP间使用MPLS能够解决BGP路由黑洞的同时，简化BGP拓扑、不引入其他域路由来减少Core内路由表。项、防止私网访问Core。 LDP使用UDP发现LSR邻居，使用TCP交互标签信息。 为直连路由分配隐含空标签，为非直连路由分配正常标签，不为BGP分标签。 VPN Overlay的方式建立VPN，在CE之间建立，包括GRE、IPSec；PE之间建立无法区分用户私有网络，不具有可行性。 Peer to Peer方式建立VPN]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习实战]]></title>
    <url>%2F2018%2F05%2F10%2FlearnVue%2F</url>
    <content type="text"><![CDATA[前言学习Vue.js框架。 vue安装与初始化工程安装yarn1npm install -g yarn 安装vue与vue-cli12yarn add vueyarn add vue-cli 创建工程，之后输入工程名称、工程描述、作者等信息1vue init webpack vueproject 进入工程，安装运行工程，之后可在8080端口查看工程12npm installnpm run dev 说明 格式 例子 文本 1输出html代码|v-html|```&lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt; 属性值|v-bind 缩写:|v-bind:class1JS表达式|```&#123;&#123;&#125;&#125;```|```&#123;&#123;5+5&#125;&#125; 判断指令|v-if|v-if1监听指令|v-on 缩写@|```&lt;button v-on=&quot;doSonething&quot;&gt;&lt;/buton&gt; 数据绑定|v-model|]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ONOS容器集群、组播环境搭建]]></title>
    <url>%2F2018%2F05%2F04%2Fonos-cluster%2F</url>
    <content type="text"><![CDATA[前言对github pages的第一次实验，静态的网页生成使用hexo。本篇包括对github使用的一些笔记以及OpenSuse的一些笔记。 搭建docker可视化管理平台本可视化平台采用portainer，拉取平台docker镜像：1docker pull portainer/portainer 创建容器，并将容器的9000端口暴漏出来：12345docker run -d -p 9000:9000 \ --restart=always \ -v /var/run/docker.sock:/var/run/docker.sock \ --name prtainer-test \ portainer/portainer 搭建onos集群拉取onos镜像：1docker pull onosproject/onos 根据镜像创建三个onos容器：123docker run -d -p 8181:8181 --restart=always --name onos-a onosproject/onosdocker run -d -p 8181:8182 --restart=always --name onos-b onosproject/onosdocker run -d -p 8181:8183 --restart=always --name onos-c onosproject/onos 创建拓扑并连接到控制器通过portainer界面查看容器IP，界面URP为“主机IP:9000”，得到三个容器IP为172.17.0.3、172.17.0.6、172.17.0.7通过mininet创建拓扑，并更改三个交换机所连接的控制器1234mn --topo=linear,3 --controller=remote,ip=127.0.0.1ovs-vsctl set-controller s1 tcp:172.17.0.3:6653ovs-vsctl set-controller s1 tcp:172.17.0.6:6653ovs-vsctl set-controller s1 tcp:172.17.0.7:6653 通过8181、8182、8183端口访问三个控制web界面，将openflow的APP激活，控制器便可以控制交换机 创建控制器集群通过onos-form-cluster脚本生成JSON代码下发到北向REST接口中1/opt/onos/bin/onos-form-cluster 172.17.0.3 172.17.0.6 172.17.0.7 之后可通过8181、8182、8183查看集群控制状态。 搭建完成后可通过portainer管理界面暂停ONOS容器与恢复ONOS容器查看控制器抗毁状态 ONOS组播起用mcast,mfwd应用，使用命令： 1mcast-join 10.0.0.1 224.1.1.1 of:0000000000000002/1 of:0000000000000002/2 命令为：mcast-join 组播源地址 组播组地址 组播源端口 组播目的端口]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>ONOS</tag>
        <tag>Mininet</tag>
        <tag>portainer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker网络搭建]]></title>
    <url>%2F2017%2F11%2F29%2FDocker%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[创建网桥与查看123docker network create --driver bridge sdn_netdocker network create --driver bridge --subnet 172.25.0.0/16 sdn_net Docker默认创建的容器使用bridge网络，容器之间互通通过bridge；容器与主机或外网互通使用NAT方式。 查看当前docker网络： 1sudo docker network list 详细内容（bridge为list查出的网络名称）： 1sudo docker network inspect bridge 容器中使用网桥1docker run -tid --net=bridge,sdn_net --name docker_br1 ubuntu 运行容器： 1sudo docker exec -ti docker_br1 /bin/bash 容器中添加网卡获得容器进程号并设置namespace的网络 12nspid=$(docker inspect -f '&#123;&#123;.State.Pid&#125;&#125;' testns)ln -s /proc/$&#123;nspid&#125;/ns/net /var/run/netns/$&#123;nspid&#125; 添加link： 1Ip link add veth1 type veth peer name veth2 添加端口容器： 12345ip link set dev tt0 name eth1 netns $&#123;nspid&#125;ip netns exec $&#123;nspid&#125; ip link set dev eth1 upip netns exec $&#123;nspid&#125; ip addr add 10.65.120.48/16 dev eth1ip netns exec $&#123;nspid&#125; ip addr add 10.65.120.49/16 label eth1:1 deveth1 容器中安装网络工具123apt-get update #更新软件源apt-get install net-tools #安装ifconfigapt-get install iputils-ping #安装ping 运行容器1docker exec -ti docker_br1 /bin/bash Docker管理 Docker管理面板 Portainer 部署在9000端口，会下载对应的docker image 12$ docker volume create portainer_data$ docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer Dockers查找镜像 1docker search centos7 拉取镜像： 1docker pull centos]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quagga的安装与配置]]></title>
    <url>%2F2017%2F11%2F29%2FQuagga%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Quagga的安装与配置 安装Quagga 1apt-get install quagga #安装Quagga 复制zebra配置文件,若需要同样复制RIP、OSPF或BGP等配置文件 1cp /usr/share/doc/quagga/examples/zebra.conf.sample /etc/quagga/zebra.conffa 删除zebra.conf最后的log注释，方便根据日志查看错误 运行zebra 1/usr/lib/quagga/zebra -d *注：在Docker中运行zebra会出现：zebraprivs_init: initial cap_set_proc failed，需要在创建容器时添加–privileged，如下： 1docker run -ti --privileged --name docker_br1 ubuntu ##登陆zebra 1telnet localhost 2601 各协议端口如下表 程序 端口/协议 说明 zebra 2601/tcp zebra vty ripd 2602/tcp RIPd vty ripngd 2603/tcp RIPngd vty ospfd 2604/tcp OSPFd vty bgpd 2605/tcp BGPd vty ospf6d 2606/tcp OSPF6d vty ospfapi 2607/tcp ospfapi isid 2608/tcp ISISd vty OSPF协议进入配置模式并进入OSPF配置 12config terminalroute ospf 配置OSPF的进程route id，并配置、起用网络6.6.6.0/24在area1中 12router-id 7.7.7.7network 6.6.6.95/24 area 1]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Quagga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edge浏览器扩展插件]]></title>
    <url>%2F2017%2F02%2F20%2FEdgeExtension%2F</url>
    <content type="text"><![CDATA[前言Edge浏览器添加插件方法总结,本想在Edge上添加Chrome插件实现视频播放悬浮，方便看视频时浏览其他网页，但发现Chrome上也没有什么好插件。Video Tap等插件经过转换桥接后在Edge上均不能实现正常功能。在搜索后发现Tempermonkeyd运行的js脚本中有实现此功能的多种插件：pop flash,flash viewer等。 Chrome插件转Edge插件在Windows商店下载Microsoft Edge ExtensionToolkit工具可将Chrome插件转为Edge支持插件（点此前往Windows应用商店下载）。 将需要转换的Chrome插件下载到本地，由于为crx后缀，需要手动更改为zip后缀解压，这样转换工具才可以读取插件源文件。工具解析插件后一般会出现 chrome-extension协议需要替换和manifest.json中资源列表格式不正确两类错误。 chrome-extension错误只需要将其替换为ms-browser-extension便可修改；manifest.json格式错误需要根据官方格式（https://developer.microsoft.com/en-us/microsoft-edge/platform/documentation/extensions/api-support/supported-manifest-keys/json-manifest-example/）进行修改。大多数需要修改如下内容： 1) author字段不能为空 2) default_icon字段的{ENTRT_SIZE}需要为一个确定值例如36，40 3) background缺少参数persistent 修改完成错误后，工具便会自动生成ChromeAPI的桥接(backgroundScriptsAPIBridge.Js，contentScriptsAPIBridge.js等)文件。这样便可在Edge浏览器中添加插件。 参考自Chrome扩展移植到Edge浏览器教程 经过实践，包括VideoTape、惠惠购物助手等插件虽然能够成功转换，但使用效果不佳或者可以加载但没有任何作用。 Edge自定义插件安装首先浏览器地址栏输入 about:flags ，进入开发者设置页，启用开发扩展功能。 然后扩展管理页就会新增一个按钮，点击加载扩展然后选择扩展的文件夹即可。 Edge的Tampermonkey插件Tampermonkey可以加载JS插件作为脚本，可以在Windows商店进行下载该扩展。 Tampermonkey可在https://greasyfork.org/zh-CN/scripts网站中查找JS脚本添加新功能，或者新建脚本自己实现功能。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Edge</tag>
        <tag>Extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDN网络虚拟化]]></title>
    <url>%2F2017%2F02%2F15%2FSDN_NV%2F</url>
    <content type="text"><![CDATA[前言对SDN网络虚拟化技术的一些整理。包括目前流行的OpenVirteX和OpenDaylight上的VTN模块的简介。 传统的网络虚拟化技术，如VLAN和VPN，设备运行着各自的转发逻辑，对这样的网络进行虚拟化需要分别对每一台设备进行操作，再加上不同厂商的设备具有不同的硬件架构和软件逻辑，因此网络虚拟化的配置和操作通常是非常复杂的。另外由于自动化的缺失，当虚拟网络发生变化时，更改原来的配置工作量将十分巨大，因此并不适合构建网络虚拟化平台。 SDN的集中控制和可编程能力则恰好解决了上述问题，即可以在集中式架构的合适位置引入“转换单元”，按照一定的策略实现虚拟逻辑资源与真实物理资源间的映射。这种映射可以非常灵活，虚拟逻辑资源可能是物理资源的一个子集，也可能是完全解耦于物理资源的。当虚拟网络发生变化时，“转换单元”还可以自动调整映射的策略。通过SDN这种集中式可编程特性实现自动化，可以简化传统网络虚拟化场景中复杂的配置工作，使网络虚拟化技术能够更具灵活性和弹性。 在基于SDN的网络虚拟化平台中，“转换单元”可以工作在不同的位置上，从而带来不同的性能特征，主要可以分为以下3类，分别与计算虚拟化的BareMetal、HyperVisor、OSContainer这3类技术相对应。 1) 转换单元集成于交换机中。每个物理交换机运行多个虚拟交换机实例，每个实例连接一个控制器，转换单元根据虚拟网络的映射信息把流量交付给相应的控制器进行处理。在这种思路下，虚拟化直接在转发设备上进行，可类比于计算虚拟化中的BareMetal方式。ONF在OF-CONFIG的白皮书中提及了这种情况，即一个物理的OF-CapableSwitch中可以有多个OF-LogicalSwitch。 2) 转换单元作为一个独立的外置设备，工作在物理交换机和各虚拟网络的控制器之间。在这种情况下，转换单元根据虚拟网络的映射信息，对物理交换机和控制器之间交互的信令进行转换，将控制信令交付给正确的控制器和物理交换机处理。在这种模式下可以将“转换单元”看作物理交换机和控制器间的透明代理。这种思路可以类比于计算虚拟化中的HyperVisor方式，其代表技术有FlowVisor、VERTIGO和OpenVirtex等。 3) 转换单元位于控制器中，作为控制器中一个特殊的APP。这种模式下，虚拟网络的用户共同接受一个控制器的调度，不同的虚拟网络可以运行不同的APP。这种思路类比于计算虚拟化中的Container方式，FlowN是基于该思路进行设计的，OpenDayLight通过VTN组件实现了网络虚拟化，NVP也是基于这种方式实现数据中心中多租户的隔离。 OpenVirteX简介OVX被分为如下几个主要部分： 面向网络的南向接口：用于建立和维持基础设施（PhysicalNetwork），管理OVX和数据路径（datapath）之间的OpenFlow信道。 面对租户的北向接口：呈现由软件交换机（OVXSwitches）和虚拟链路（OVXLinks）构成的虚拟网络中的每个租户，管理OVXSwitches和租户控制器之间的OpenFlow信道。 全局映射Globalmap（OVXMap，PhysicalPort.ovxPortMap）：完成虚拟网络和物理网络之间的相互映射，并且连接这两个网络。 API server：监听JSONRPC调用系统配置和系统/网络状态信息。 Globalmapping在创建OVXNetwork时完成，虚拟网络和物理网络的信道管理在分离的IO循环中完成。对于每个消息，循环会做如下处理：1）有一个源或目的OVXNetwork；2）必须穿过北向南向分界，也就是必须调用virtualize()和devirtualize()方法。OVX南北向接口的这种默认解耦状态使在运行时期动态重配置OVXNetwork成为了可能，可通过API调用来操纵全局映射，并且允许OVX保留到网络的连接即使在租户不存在的情况下。 OVX不仅拥有底层物理网络拓扑，而且还有每个租户的虚拟网络拓扑。底层的物理网络拓扑是通过OVX下发LLDP报文获取到的，而上层的虚拟网络拓扑则是由OVX生成的。即租户的控制器下发的LLDP报文不会直接送到底层物理网络，而是在OVX上通过查询底层物理拓扑，从而模拟了LLDP的过程，向上提供网络拓扑。 OVX通过映射算法，解耦了底层网络和租户网络。即南向上，OVX作为控制器，接收底层物理设备的信息，并下发流表等报文到底层设备。北向上，OVX作为交换机集合，向租户的控制器发送OF报文。从而将一条完整的控制通路，变成了两段相互独立的控制通路。而这两者之间的映射关系，保存在GlobalMap中。在下图中，蓝色部分是面向租户的，而橙色部分是面向交换机的。两者之间互不可见，即租户看不到物理的交换机数据。而绿色部分是两者结合的纽带，保存了网络映射的数据。在数据上行、下行的过程中通过查表修改的方式，翻译成正确的数据。如下图右侧所示，上行数据需要调用virtualize()函数，而下行数据需要调用devirtualize()函数。 VTN简介VTN是SDN控制器中用于提供多租户虚拟网络的一项应用。通常，为每个部门的系统配置网络需要耗费大量的人力、物力，同样，需要为每个租户安装各种网络应用，并且很难共享这些资源，因此，设计、部署、管理整个复杂的网络是一项繁重的任务。为了解决这一难题，OpenDaylight提出在控制器中使用VTN，VTN的独特之处在于逻辑抽象平台。VTN将逻辑层面与物理层面完全分离，用户可以设计、利用任何所需网络，并且无需了解物理网络的拓扑结构和带宽限制。 VTN允许用户根据对L2/L3层网络的感知来定义网络。由此可知，基于VTN设计的网络会自动被映射到底层物理设备，并配置到支持SDN控制协议的独立的交换机上。这样不仅屏蔽了底层网络的复杂性而且可以更好的管理网络资源，减少了网络服务的配置时间和配置错误。 从VTN架构图我们可以看出，VTN共分为两个模块：VTN Manager和VTNCoordinator。VTN通过映射机制将虚拟网络资源（比如port，bridge，route）映射到物理资源上，包在租户内转发其实是在物理资源上进行转发，隔离机制是利用OpenFlow协议，转发时通过在支持OpenFlow的交换机上通过流表判断包的转发。 Manager位于controller内部，相当于控制器的一个plugin。它提供了REST接口对其进行增删改查。它还提供了对Openstackl2的网络api。以下是VTN Manager和VTN Coordinator的关系图。VTNCoordinator通过ODC Driver与控制器中的VTNManager还有拓扑模块，交换机管理模块相连。 VTN Coordinator通过北向接口与控制器相连接。其本身也提供REST API。一个Coordinator可以控制多个Controller。Coordinator通过刚开始静态下发配置，而不是在Manager收包后上交给Coordinator做收包决策。 VTN采用三种映射： 1) 端口映射：将物理交换机端口（三元组：交换机ID，端口ID，VLAN ID）映射到vBridge的端口。两者是一对一的关系。 2) VLAN映射：将物理交换机（二元组：交换机ID，VLAN ID或一元组：仅VLAN ID）映射到vBridge。多个VLAN ID可以map到一个vBridge，但是一个VLAN ID不能同时map到多个vBridge。Port类型为internel的无法被map。注意vlan是映射到vBridge，而不是vBridge的interface，但是实际在操作过程中，vBridge会起虚拟port对应相应的interface，该虚拟port作用相当于interface。 3) MAC 映射：将主机的MAC地址映射到vBridge的一个端口。（Helium版本仅在manager中支持，Lithium版本将会在coordinator中支持）该映射可以用于虚机迁移，也可以允许或禁止某些主机的通信。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>OpenVirteX</tag>
        <tag>VTN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《未来边缘》记]]></title>
    <url>%2F2017%2F01%2F08%2FedgeOfFuture%2F</url>
    <content type="text"><![CDATA[《未来边缘》是刘慈欣的一本科幻小说集其中包含：天使时代、命运、2018年4月1日、赡养上帝与微纪元五篇短片科幻小说。给我了五次神奇的思维旅行。 天使时代大刘通过将基因工程与软件工程进行类比、碱基对与二进制进行对比。脑洞大开，在小说中将编码产生基因与生命得以实现。由于此方法的发现者来自贫穷的非洲国家，作为一个热爱国家与民族的诺贝尔获得者，开始改写非洲孩子的基因。为了让非洲人民免于饥饿，让这些孩子可以像羊一样吃草跟树叶来获取能量。但不幸的是来自欧美国家的人们认为这是反人性的。于是通过联合国、通过武装力量向这个贫穷的非洲国家宣战，来迫使他们交出这些不再正常的孩子们。当战火洒向这个落后国家时，国家的武装迅速被解除了。留下只有交出孩子这一条路。但等到接收看押所有孩子时，发现另外的两万孩子是带着武器来的。这些武装的孩子们有着鸟一样的翅膀，像天使一样向美国航母战斗群发起了进攻。进攻的突然性与攻击方式的另类使得他们赢得了这场战斗，击沉了航母。 整个故事正如小说中这位诺贝尔获得者所说的：即使所谓的文明世界，只要有需要，伦理是第二位的。那些人们当然不需要吃野草和树叶，但他们肯定是需要飞翔，这是人类最古老的梦幻，没人能抵挡它的诱惑。 命运讲述了一艘飞船误入了时间蛀洞，发现一颗小行星正向地球俯冲而来，为了保护地球这艘飞船将一颗发动机砸向小行星，使小行星偏离了轨道。当他们正享受英雄的快乐时，发现时间蛀洞将他们带到的是白垩纪，这颗小行星很有可能是灭绝恐龙的那颗。怀着忐忑的心，他们又反穿回时间蛀洞，降落到地球上，发现地球早已经被恐龙所统治，恐龙发展出了自己的科技，而人类成为了恐龙的食物与动物园里的野兽。可笑的是他们还作为拯救恐龙的英雄而被恐龙所供奉。 这篇文章感觉与《最璀璨的银河》中的《诗云》似乎有承接关系，因为诗云也是将人类作为恐龙的食物，而且也是在太阳系，不过好像《诗云》中的恐龙貌似是外星人。《最璀璨的银河》中的《白垩纪往事》也属于恐龙这一题材的文章。 2018年4月1日这篇文章比较简单，主要介绍了基延、冬眠与虚拟王国这三个科幻概念和他们对一个普通人生活的影响，是对新技术的一种思考。其中基延是指通过改变人类的死亡基因使得人类寿命大大延长的生物技术，而冬眠是指使人类通过类似冬眠的方式来达到“时间旅行”的技术，虚拟王国是通过互联网等虚拟技术高度发展后，技术人员寻求获得与真实国家类似的政治权利而产生的与真实国家想对应的虚拟国家。于是就有了文中一对情侣的短暂故事，男方通过窃取公司资金希望获得基延，但又留念女友，而女方希望通过冬眠来逃避现实的残酷。最终双方的脆弱感情被现实所撕裂。 前两个生物技术使得人类思想发生了很大的变化。基延使得有钱人获得更长的寿命，普通人不仅在生活上开始与富人拉开差距，在生命面前也开始变得不再平等，这也就造成社会矛盾的增大，同样也就促使虚拟王国的产生。由于未来技术更加廉价、更加发达，因此通过冬眠获得“时间旅行”的人也更多。基延的高价格促成虚拟国家的诞生，由于虚拟国家主要由技术人员产生，他们权利低工资少，但社会正是由千千万万的技术人员在不同却重要的岗位所支撑的，于是他们试图通过虚拟国家来实现虚拟货币的人人均富，来改变现实社会的贫富矛盾。文章随小，但反应的社会与人类显示却并不简单。 赡养上帝一天地球上突然出现了许多的飞船，这些飞船上来的都是一些白头发白胡须的老人。这些老人声称是人类的上帝，是人类的创造者。人类陷入了有史以来的兴奋中，上帝提出希望通过为人类提供技术来换取人类对他们这些老人的赡养。于是每个家庭分配了一个上帝功人类赡养。但当人类发现上帝的技术太过发达而难以应用，随着时间的变迁，人类早已忘掉上帝来时的兴奋与创造自己的感恩，只有对抚养一个无所事事且寿命长久的老人的愤懑。上帝开始遭到人类整体的嫌弃。最终上帝开始遭到漫骂与家庭暴力。上帝开始出走，开始回到他们的飞船上，开始漫无目的再次旅行。在与上帝相处的日子里，人类了解到了人类文明也像一个人一样有童年、青年、中年与老年，而上帝就是一个老年文明，地球则是一个童年文明。每个文明都会去播种文明，希望在成为老年文明时，这个播种文明会赡养自己。同时告诉地球他们播种了四个地球，其中一个地球被另外一个地球吞并，而这个地球为了获得上帝的技术不仅没有赡养上帝，反而囚禁了上帝。另外一个地球自然消亡了。同时预示着地球可能会面临这个科技发达的地球哥哥的威胁与吞并。 与其说本文是对文明周期的一个思考，不如说是对人性对于老人态度的一个思考。但感觉这个思考是偏左了一些，也许是赡养的方法不对。 这篇文章是与《最璀璨的银河》中的《赡养人类》是同一个系列的。《赡养人类》中应该就是这个地球哥哥。而这个地球哥哥却面临着另外的一个人性故事。 微纪元微纪元描写了一个在太阳烧尽后人类的生存模式，一个只有灰尘大小的人类的生存方式。人类只需要生活在直径一米的球状世界里来躲避各种灾难。灰尘大小的人类也就意味着地球上有无限的能源供之使用，也即不会再有能源危机、环境危机等等问题。而最为这么小的人类也不再怕任何宏观世界的自然灾害的威胁，因为他们太小了这些灾害很难破坏他们。在大刘的心中这是一个欢乐的世界，不知道悲伤的世界，一个完美的世界。这篇文章评价很高，但我并没有感觉到，也许是篇幅在本文中比较长，给人留下的印象比较深刻罢了。]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>Science Fiction</tag>
        <tag>Book Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages搭建相关笔记]]></title>
    <url>%2F2017%2F01%2F07%2FtestHexo%2F</url>
    <content type="text"><![CDATA[前言对github pages的第一次实验，静态的网页生成使用hexo。本篇包括对github使用的一些笔记以及OpenSuse的一些笔记。 docx转markdown使用pandoc工具：1pandoc -s example30.docx -t markdown -o example35.md 自己写了一个自动生成hexo可使用md文件的脚本：1234hexo new &quot;$1&quot;pandoc -s /home/ly/word/$1.docx -t markdown -o /home/ly/github/hexo/source/_posts/$1_doc.mdcat /home/ly/github/hexo/source/_posts/$1_doc.md &gt;&gt; /home/ly/github/hexo/source/_posts/$1.mdrm -f /home/ly/github/hexo/source/_posts/$1_doc.md 搭建github pages参考文章搭建方法1搭建方法2不蒜子统计计数markdown语法 OpenSuse安装scrapy确定python与pip版本为python2.7安装python-devel与libxml2-devel1pip install scrapy github上传文件1234git remote add origin https://github.com/ly286289/ly286289.github.io.gitgit add Readme.mdgit commit -m "first commit"git push origin master 创建ssh key: 123[root@94a598463d56 home]# git config --global user.name "Lou Yang"[root@94a598463d56 home]# git config --global user.email "ly286289@sina.com"[root@94a598463d56 home]# ssh-keygen -t rsa -C "ly286289@sina.com" 复制公钥到github: 1cat /root/.ssh/id_rsa.pub git产生的SSH密钥权限： 123chmod 755 ~/.ssh/ chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub chmod 644 ~/.ssh/known_hosts 杂项Linux查看硬件配置：1dmidecode | more Linux中文安装，bash错误提示英文显示：在.bashrc中添加LC_MESSAGES=”en_US.UTF-8”]]></content>
      <categories>
        <category>搭建平台</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>Github</tag>
        <tag>OpenSuse</tag>
        <tag>Hexi</tag>
      </tags>
  </entry>
</search>
